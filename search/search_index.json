{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Documentation for the SystemC Learning repository</p>"},{"location":"02-constructor/","title":"Example2","text":"<p>The main structure of systemC is the <code>SC_MODULE</code>. The syntax is the following:</p> <pre><code>SC_MODULE(module_name){\n    SC_CTOR(module_name){\n        cout &lt;&lt; \"Hi, I'm the constructor\" &lt;&lt; endl;\n    }\n}\n</code></pre> <p>The <code>SC_CTOR</code> function is the constructor that is executed when the object is instanced. </p>"},{"location":"03-periodic-counter/","title":"Example3","text":"<p>This code runs a counter 10 times, since the <code>SC_METHOD</code> is executed every every 10ns. It is important to remember that a method expect to have a <code>next_trigger</code> function at the end, otherwise it will be executed only once. This is clearly visible from the output of the program</p> <p><pre><code>Counter initialized\nCounter value: 0\nCounter no next trigger value: 0\nCounter value: 1\nCounter value: 2\nCounter value: 3\nCounter value: 4\nCounter value: 5\nCounter value: 6\nCounter value: 7\nCounter value: 8\nCounter value: 9\n</code></pre> The reason behind stands in the fact that the <code>SC_METHOD</code> can be seen as a programming function. This means that is executed only one when called. To schedule another execution, the <code>next_trigger</code> should be specified</p> <p>It is also important to remember that the method should be initialized in the <code>SC_CTOR</code>. This is needed because SystemC must register it in the simulation kernel.</p> <pre><code>SC_CTOR(counter){\n    ...\n    SC_METHOD(count);\n    SC_METHOD(count_no_next_trigger);\n}\n</code></pre>"},{"location":"04-periodic-counter-thread/","title":"Example4","text":"<p>This examples is really similar to the previous one. The only difference is the usage of <code>SC_THREAD</code>. This macro allows to define a thread. The latter is executed only one, and in fact the usual syntax is the following:</p> <pre><code>void count_thread() {\n    while (true) {\n        // Do something\n        wait(10, SC_NS);\n    }\n}\n</code></pre> <p>As we can see, inside the thread, there is a <code>while(true)</code>. In fact the thread should run indefinetely, and should be put in wait after the execution. The <code>wait</code> statement suspend the thread and allows simulation time to continue. This is substantially different compared to the <code>SC_METHOD</code> which does not allow simulation time to continue between the invocation and the return of the function</p>"},{"location":"05-periodic-counter-thread-and-method/","title":"Example5","text":"<p>This examples shows the usage of both method and thread. </p> <pre><code>Counter initialized\nTIME@ 0 s METHOD: Counter value: 0\nIncrementing counter inside METHOD\nTIME @0 s THREAD: Counter value: 1\nIncrementing counter inside THREAD\nTIME @10 ns THREAD: Counter value: 2\nIncrementing counter inside THREAD\nTIME@ 20 ns METHOD: Counter value: 3\nIncrementing counter inside METHOD\nTIME @20 ns THREAD: Counter value: 4\nIncrementing counter inside THREAD\nTIME @30 ns THREAD: Counter value: 5\nIncrementing counter inside THREAD\nTIME@ 40 ns METHOD: Counter value: 6\nIncrementing counter inside METHOD\nTIME @40 ns THREAD: Counter value: 7\nIncrementing counter inside THREAD\nSimulation ending @50 ns\n</code></pre> <p>As we can see from the output the <code>THREAD</code> is executed every <code>10ns</code>, while the method every <code>20ns</code>. The difference is that the first one is using a <code>wait()</code>, while the second one a <code>next_trigger()</code> statement. </p> <p>If we try to put a <code>wait()</code> statement inside the <code>METHOD</code>, like the following code: <pre><code>void count_method() {\n    cout &lt;&lt; \"TIME@ \" &lt;&lt; sc_time_stamp() &lt;&lt; \" METHOD: Counter value: \" &lt;&lt; cnt &lt;&lt; endl;\n    cnt++;\n    cout &lt;&lt; \"Incrementing counter inside METHOD\" &lt;&lt; endl;\n    next_trigger(sc_time(20, SC_NS));\n    wait(10, SC_NS);\n}\n</code></pre></p> <p>we get the following error:</p> <pre><code>Error: (E519) wait() is only allowed in SC_THREADs and SC_CTHREADs: \n    in SC_METHODs use next_trigger() instead\n</code></pre> <p>This is reasonable, since the <code>wait()</code> statement is not allowed inside the <code>SC_METHOD</code> function. In fact, given the timing behaviour of the <code>SC_METHOD</code>, the <code>wait</code> statement would block the execution of the rest of the simulation. </p>"},{"location":"06/","title":"06","text":"<p>The previous example introduced concurrency. This is a specific characteristics of real world systems. In fact, a general system has many thing happening in the same time or with some kind of dependency one to the other (i.e on the positive edge of the clock something on a signal happens).</p> <p>SystemC supports events, which are used to exploit concurrency based design. </p> <p>The example implements a design with an event driven counter. The two design are really similar, there are only a few difference:</p> <p>1) Initialization of the event: To use the event we need to initialized them inside our module. This is done in the following way:     <pre><code>SC_MODULE(counter) {\n    // ...\n    sc_event increment_cnt;\n    // ...\n}\n</code></pre> 2) Changing the <code>count_thread</code> method by adapting the <code>wait()</code> function to wait for the signal and not for a specific time interval.      <pre><code>void count_thread() {\n    while (true) {\n        // ...\n        wait(increment_cnt);\n    }\n}\n</code></pre>     This is really easy, since we just pass the signal as a parameter of the <code>wait()</code> method. </p> <p>3) Write a <code>SC_METHOD</code> (or <code>SC_THREAD</code>) that triggers the signal.      <pre><code>void trigger_increment_cnt() {\n    increment_cnt.notify();\n    next_trigger(10, SC_NS);\n}\n</code></pre>     This function executes the <code>notify()</code> method on the signal, which IMMEDIATELY triggers the signal. Then, since <code>trigger_increment_cnt()</code> is a method, it is rescheduled after 10ns.</p> <p>The output of the program is the expected one:</p> <pre><code>Counter initialized\nTIME @0 s THREAD: Counter value: 0\nIncrementing counter inside THREAD\nTIME @10 ns THREAD: Counter value: 1\nIncrementing counter inside THREAD\nTIME @20 ns THREAD: Counter value: 2\nIncrementing counter inside THREAD\nTIME @30 ns THREAD: Counter value: 3\nIncrementing counter inside THREAD\nTIME @40 ns THREAD: Counter value: 4\nIncrementing counter inside THREAD\nSimulation ending @50 ns\n</code></pre> <p>So we get exactly the same behaviour but by using events.</p>"},{"location":"08-ports/","title":"08 ports","text":"<p>The counter does not reset after the first for because on the rising edge of the clock the reset is down. </p> <p>To exploit reset, we should modify the code as follows:</p> <pre><code>reset = true;\nsc_start(1, SC_NS);\nclk = true;\nsc_start(1, SC_NS);\nreset = false; // Release reset\nclk = false;\n</code></pre> <p>As you can see, compared to the original version, the line <code>reset = false;</code> is removed. By doing this, the output waves are the following:</p> <p></p>"},{"location":"09-async-reset/","title":"09 async reset","text":"<p>Here there is the async reset, so when the rst goes up the counter is resetted to 0. </p>"}]}